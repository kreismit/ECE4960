<h4 style="background-color:LightGray" id="navbar"><a href="#L1">&emsp;Lab 1&emsp;</a><a href="#L2">&emsp;Lab 2&emsp;</a><a href="#L3">&emsp;Lab 3&emsp;</a><a href="#L4">&emsp;Lab 4&emsp;</a><a href="#L5">&emsp;Lab 5&emsp;</a><a href="#L6">&emsp;Lab 6&emsp;</a></h4>

<h1 id="L1"> Lab 1</h1>

## Goal

The purpose of this lab was to get acquainted with the [SparkFun Artemis Nano](https://www.sparkfun.com/products/15443) and with our custom Ubuntu VM.

## Materials

* 1 SparkFun Artemis RedBoard Nano
* 1 USB A-C cable
* 1 lithium-polymer rechargeable battery
* 1 laptop

## Procedure

### The IDE

Installed [Arduino from the Arch Linux repos](https://wiki.archlinux.org/index.php/Arduino). Only the IDE supports Artemis boards. `arduino-avr-core` is required for the IDE.

Installed the [Arduino core](https://github.com/sparkfun/Arduino_Apollo3) in the IDE:

* Open Tools > Board > Boards Manager in the IDE
* Search for apollo3
* Choose version 1.1.2 in the drop-down
* Click Install (this took several minutes)

Chose the "SparkFun RedBoard Artemis Nano" as the board.

### Testing

Uploaded four example sketches to test various parts of the board:

* Blink (from built-in examples)
* Example2_Serial (from SparkFun Apollo3 examples)
* Example4_analogRead (SparkFun)
* Example1_Microphone (SparkFun)

Also modified Example1_Microphone to blink the built-in LED when whistling.

## Results

### IDE

One pitfall was accessing the COM port, as Linux doesn't give users read-write permission by default. The permanent fix was a custom `udev` rule:
```shell
SUBSYSTEM=="tty" ATTRS{vendor}=="0x8086" ATTRS{subsystem_device}=="0x0740" MODE="0666"
```
Note that the exact requirements for this rule depend on the computer and the distro.

### Testing
The Blink example worked, blinking the blue LED labeled 19.
<video width="600" controls><source src="Lab1/Videos/Blink.mp4" type="video/mp4"></video>

The Serial example both input and output text via the USB serial connection.
<video width="600" controls><source src="Lab1/Videos/Serial.mp4" type="video/mp4"></video>

The analogRead sketch read temperature values which noticeably rose as I held my warm thumb against the device.
<video width="600" controls><source src="Lab1/Videos/Analog.mp4" type="video/mp4"></video>

The Microphone example showed that the loudest frequency doubled when I whistled an octave, indicating that the microphone is working well.
<video width="600" controls><source src="Lab1/Videos/Microphone.mp4" type="video/mp4"></video>

I added two pieces of code to the Microphone example to make it blink the LED when I whistle.

In `void setup()`:
```c++
pinMode(LED_BUILTIN,OUTPUT);
```
In `void loop()`:
```c++
if(ui32LoudestFrequency>800 && ui32LoudestFrequency<2000)
    digitalWrite(LED_BUILTIN,HIGH); // blink the LED when frequency is in whistling range
  else
    digitalWrite(LED_BUILTIN,LOW); // and not otherwise
```

This worked well. (It also picked up my squeaky chair or tapping on my desk.)
<video width="600"><source src="Lab1/Videos/WhistleDetect.mp4" type="video/mp4"></video>

While the Artemis Nano was plugged into my computer, plugging the battery in lit the yellow CHG light.

I commented out all the serial lines of code so that the board would not attempt to establish serial communication with my computer. Then, the board would recognize my whistle on battery too.

[See my code for Lab 1 here.](https://github.com/kreismit/ECE4960/tree/master/Lab1)

<h1 id="L2"> Lab 2</h1>

## Goal

## Materials

* 1 Artemis Nano
* 1 USB dongle
* 1 USB A-C cable
* 1 computer running the Ubuntu 18 VM


## Procedure

### Setup

Downloaded the [distribution code](https://cei-lab.github.io/ECE4960/ece4960lab2dist.zip).
(Re)installed `bleak` using `pip install bleak` at the command line.
Downloaded the sketch `ECE_4960_robot` to the Artemis and opened the serial monitor at 115200 baud.

Entered the folder generated by extracting the ZIP. Ran `./main.py` twice while the Artemis Nano was powered on to discover the board. Manually cached the Artemis' MAC address to `settings.py`.

### Ping Test

Commented out `pass` and uncommented `# await theRobot.ping()` under `async def myRobot.Tasks()` in `main.py`. Ran `./main.py` again while the Arduino serial monitor was still open. Copied the data from the terminal; pasted into a spreadsheet and set space as the delimiter; generated statistics.

### Request Float

Modified `case REQ_FLOAT` in the Arduino sketch `ECE_4960_robot.ino` as follows:

```c++
	case REQ_FLOAT:
		Serial.println("Going to send a float");
        res_cmd->command_type = GIVE_FLOAT;
        res_cmd->length = 6;
        ((float *) res_cmd->data)[0] = (float) 2.71828; // send e
        amdtpsSendData((uint8_t *)res_cmd, res_cmd->length);
		break;
```

In `main.py`, commented `await theRobot.ping()` and uncommented `await theRobot.sendCommand(Commands.REQ_FLOAT)`. Reran `main.py` and received the floating-point value of *e*.

### Bytestream Test

In `main.py`, commented `await theRobot.sendCommand(Commands.REQ_FLOAT)` and uncommented `await theRobot.testByteStream(25)`. Added the following code to `ECE_4960_robot.ino` within `if (bytestream_active)`:

```c++
Serial.printf("Stream %d after %3.1f ms latency\n", bytestream_active, (micros() - finish)*0.001);
int numInts = 3;          // how many integers will fit in this stream
bytestreamCount++;        // we are sending one bytestream now
res_cmd->command_type = BYTESTREAM_TX;
// Two bytes for command_type and for length;
res_cmd->length=2+bytestream_active*numInts; // then 4 bytes for each uint32_t and 8 for each uint64_t
start=micros();
uint32_t integer32 = 0xffffffff;  // different values to indicate whether we're getting a 32-bit
uint64_t integer64 = 0xffffffffffffffff;  // or a 64-bit number
uint32_t *p32;            // pointers to the appropriate data types
uint64_t *p64;
switch(bytestream_active){
  case 4:                 //asked for a 4-byte number!
  p32=(uint32_t*) res_cmd->data;
  for(int i=0; i<numInts-2; i++){ // the -2 is so the last two values can be the time and the count
      memcpy(p32, &integer32, sizeof(integer32));
      p32++;                      // move 4 bits down the array
    }
    memcpy(p32, &bytestreamCount, sizeof(bytestreamCount));
    p32++;
    memcpy(p32, &start, sizeof(start));
    break;
  case 8:               //asked for an 8-byte number!
  default:              // the default is to send a 64-bit (8-byte) array
    p64=(uint64_t*) res_cmd->data;
    for(int i=0; i<numInts-2; i++){
      memcpy(p64, &integer64, sizeof(integer64));
      p64++;                      // move 8 bits down the array
    }
    bytestreamCount64 = (uint64_t) bytestreamCount;
    memcpy(p64, &bytestreamCount64, sizeof(bytestreamCount));
    p64++;
    memcpy(p64, &start, sizeof(start));
    break;
}
amdtpsSendData((uint8_t *)res_cmd, res_cmd->length);
finish=micros();
Serial.printf("Finished sending bytestream after %u microseconds\n",finish-start);
```

where `start` and `finish` were defined as global variables and `finish` was initialized to zero.

Repurposed `bytestream_active` to tell the Artemis how large an integer to send; if `bytestream_active==4` then the Artemis sends back an array of 32-bit (4-byte) integers, and if `bytestream_active==8` then the Artemis sends back 64-bit integers. These maximum values were confirmed by setting `integer32=0xffffffff` and `integer64=0xffffffffffffffff` as the maximum values that can be sent. Because of this usage, changed `await theRobot.testByteStream(25)` to `await theRobot.testByteStream(4)` in the 32-bit case or `await theRobot.testByteStream(8)` for the 64-bit case.

Added the following code to `main.py` within `if code==Commands.BYTESTREAM_TX.value:`

```python
# dataUP = unpack("<III",data) # for 3 32-bit numbers 
dataUP = unpack("<QQQ", data) # for 3 64-bit numbers
# print(f"Received {length} bytes of data")
print(dataUP)
```

## Results

### Ping Test

<video width="600" controls><source src="Lab2/Videos/Ping.mp4" type="video/mp4"></video>

The Bluetooth icon in the statusbar does not appear until `main.py` is run. This indicates that the Python script, rather than the Ubuntu Bluetooth wizard, is establishing the connection.

The ping latency followed this histogram:

<image width="600" src="Lab2/Images/PingRTTHistogram.png"></image>

Using the setting `"OutputRawData": True` in `settings.py` showed me that returning a ping sends 96 bytes of data, all zeroes. Thus, the transfer rate followed this histogram:

<image width="600" src="Lab2/Images/PingRateHistogram.png"></image>

Most of the "rate" in this case is the latency of returning pings. From the Artemis side, I measured the average time between pings as *160.0 ms*. The average total RTT as measured by the Python script was *159.3 ms*. The Artemis sends data very quickly.

### Request Float

<image width="600" src="Lab2/Images/Float.png"></image>

The traceback at the bottom occurred because I stopped the program with Ctrl+C.
Note that although the floating-point value was `2.71828`, there were additional random digits. This means that floats cannot be compared like `if( float1 == float2 )`, but rather `if( abs(float1-float2) < tolerance )`.

### Bytestream Test

#### 32-bit Stream

<image width="600" src="Lab2/Images/Bytestream32.png"></image>
<image width="600" src="Lab2/Images/32-bit.png"></image>

The Python script indicates that it receives 14 bytes of data in each packet. The mean transfer rate is **963 bytes/second**. Note this is the average over the packets which were received; only **65%** of the packets made it to the computer.

<image width="600" src="Lab2/Images/32bitTransferHistogram.png"></image>

#### 64-bit Stream

<image width="600" src="Lab2/Images/Bytestream64.png"></image>
<image width="600" src="Lab2/Images/64-bit.png"></image>

The Python script indicates that it receives 26 bytes of data in each packet. The mean transfer rate is **1.46 KB/second**. Note this is the average over the packets which were received; only **22%** of the packets made it to the computer.

<image width="600" src="Lab2/Images/64bitTransferHistogram.png"></image>

## Lessons Learned

As I experienced, and as [this SuperUser post](https://superuser.com/questions/956622/no-usb-devices-available-in-virtualbox) points out, users must be part of the `vboxusers` group on the host machine, or else no USB devices are accessible from VirtualBox. This and other issues were solved when I did the following, in order:

* Add my user to the host machine's `vboxusers` group.
* In the VirtualBox settings, ensure `Enable USB Controller` is checked.
* Connect the Bluetooth USB dongle.
* Start the VM.
* In the VirtualBox menu bar, mouse to Devices > USB and check `Broadcom Corp 20702A0`.
* Run `main.py` in the CLI.

Adjusting the Ubuntu Bluetooth settings was unnecessary and caused issues. The USB dongle is more reliable than my built-in BLE radio.

Another surprise I shouldn't have experienced was that the code didn't run when I executed `python main.py`. I noted that the file was executable and began with `#!/usr/bin/env python3`. When I ran it as a script, it worked perfectly. `python` was mapped to `python2.7` and not `python3`. Always check versions.

I found that the Python code "cares" what length is sent with the message. The length must match the format string; and the code stops parsing data after `length` bytes.

Lastly, the shorter the data packets were, the more likely they were to reach their destination.

[See my code and data for Lab 2 here.](https://github.com/kreismit/ECE4960/tree/master/Lab2)

<h1 id="L3"> Lab 3</h1>

## Materials Used

* Fancy RC Amphibious Stunt car with remote
* 2 NiCd rechargeable batteries with USB charger
* 2 AA batteries
* Screwdriver
* Ruler / measuring tape
* Timer (app)
* GPS (app)
* Laptop running Ubuntu 18.04 VM with ROS Melodic Morenia


## Procedure

### Physical Robot

Charged each NiCd battery about 8-9 hours before first use (or until the red light on the USB charger stopped flashing.) Inserted NiCd battery into robot and two rechargeable AA batteries into the remote.

Collected various measurements using the available environment, a ruler, and a timer. For clocking speed, used a GPS app to get distance measurements.

### Simulation

Installed `ros-melodic-rosmon`.
Downloaded the [lab 3 base code](https://cornell.box.com/s/p4y4ovp6gu0alvqzog1hctzmcvby9eub) from Box into the folder shared between the host and the VM. Started the VM; extracted the archive; entered the folder extracted from the archive; and ran `./setup.sh`.

<image width="600" src="Lab3/Images/Setup.png"></image>

Closed and reopened the terminal emulator, per the instructions.

Started `lab3-manager`, which was now aliased as shown here. Hit `a` to enter the `Node Actions` menu; then hit `s` to start a simulator.

Opened another terminal window and ran `robot-keyboard-teleop` to allow me to control the simulation.

<image width="600" src="Lab3/Images/Teleop.png"></image>

Played the game and made the measurements below.

## Results and Lessons Learned

### Physical Robot

This video is courtesy of my apartment-mate Ben Hopkins.

<video width="600" controls><source src="Lab3/Videos/Stunts.mp4" type="video/mp4"></video>


The wheelbase is 4 in = 10.5 cm wide and 3.25 in = 8 cm long (measuring from the center of the wheels.) This measurement is useful to determine skid-steering quality.


Unless stated otherwise, the following tests were done on a flat surface.

#### Manual Control

How difficult it is to drive the robot manually helps me understand the difficulty of controlling it algorithmically.

* The three speed settings had significantly different effects. It was virtually impossible to flip when traveling slow; but at max speed I could hardly start without flipping. The top speed and the default speed were nearly the same.
* The robot can turn in place quite predictably; however, it requires a lot of power to skid the wheels, and when the battery is low, it can no longer turn in place.
* Long arc turns are difficult not to do. I could hardly drive straight even if the joysticks were maxed out. In code, driving straight will require a feedback loop.

#### Inertial Measurements

How quickly the robot accelerates and decelerates tells me a lot about the robot's power-to-weight ratio. I don't have a scale, but I can calculate its mass (at least in terms of its motor torque.)

* Acceleration: 6-8 feet to get to full speed. 6-8 feet to coast to a stop. 2-2.5 seconds to accelerate to full speed.
* Can stop quickly by reversing with slow button (2 feet)
* These numbers stayed relatively constant as the battery drained; but the maximum speed decreased.
* Average max speed at full (ish) battery: 12 ft/s = 3.5 m/s = 8 mi/h
* These measurements were the same whether the robot drove forward or backward.

#### Gravitational Measurements

OK, so I know the robot's motors are strong enough to accelerate and decelerate it quickly. How strong is that? Where is the weight in the robot?

* The robot is quite stable – it has to tilt around 75° before it flips.
* The robot is also somewhat topheavy - it flips if it accelerates or stops too suddenly.
* The motors were not very strong – it was sometimes difficult to climb hills. It could climb a 45° slope with a good battery, but it slowed significantly. Rough terrain also slowed it down since it had to climb over many short slopes.

#### Frictional Measurements

* The robot turned about its center predictably on a flat surface, but slopes made a big difference.
* The robot's turn radius was predictable at a given battery level, speed, and type of terrain. Little rocks, initial speed, battery level, and slope all made a big difference.
* Average maximum rotational speed when turning in place: 75 rpm = 7.9 rad/s
* I noticed no differences between driving on flat (hard) carpet, concrete, and asphalt.

#### Other Measurements

* The range was quite good, 250+ feet line-of-sight.
* I could drive the robot around and under cars. The signal can go around at least 10 cars in a parking lot.
* On the first and second runs, the battery lasted 35 min (when the robot was moving about 1/2 the time.)

### Simulation

<video width="600" controls><source src="Lab3/Videos/RobotSim_Functions.mp4" type="video/mp4"></video>

* The robot doesn't seem to have a minimum speed. I can reduce the input speed to 0.01 and less and still it moves (albeit around 1 square per minute.) It seems to have no maximum speed either.
* The same is true for angular speed.
* I could accelerate nearly instantly and reverse direction nearly instantly; the only limiting factor seems to be the frame rate. The time between 1x reverse and 1x forward is the same as between 3x reverse and 3x forward, or 3x forward and 3x reverse, etc.
* When I hit the wall, the robot did not bounce, flip, etc; the simulation paused and showed a warning triangle sign in the place of the robot until I backed away from the wall.
* I could grab and drag the robot using the mouse; as soon as I put the robot down, it resumed motion in the same direction as it was moving before. However, I couldn't both drag/pan and steer at once; the keyboard control only works when the terminal window running `robot-keyboard-teleop` has focus.

[Click here to see my data for Lab 3.](https://github.com/kreismit/ECE4960/tree/master/Lab3/)

<h1 id="L4">Lab 4</h1>

## Materials Used

* Sparkfun Artemis RedBoard Nano
* USB A-C cable
* SparkFun Serial Controlled Motor Driver (SCMD) module (with no jumpers soldered)
* SparkFun Qwiic (I²C) connector cable
* Fancy RC Amphibious Stunt Car
* 4.8V NiCd rechargeable battery
* Laptop with Ubuntu 18.04 VM and Arduino IDE

## Procedure

### Physical Robot

Reviewed documentation. Removed the aesthetic cover and the motor cover; cut the wires to the motors right at the connectors; stripped about 3/8" of insulation; and connected them to the SCMD. Cut the battery wires close to the control board, stripped the ends, and connected them to the SCMD. 

In Arduino IDE, installed the Serial Controlled Motor Driver library version 1.0.4 (Tools -> Manage Libraries -> search for "SCMD".) Loaded Example1_Wire (from the newly installed SCMD library); changed the I²C device address to `0x5D`; and ran it. It spun the two wheel motors. Used this command: `Serial.printf("Address %d\n",i);` within the `for` loop to tell me what the motor addresses were. Wrote code to spin the motors and found the minimum speed that made the wheels turn.

Removed the RC control board from the robot; pushed the SCMD into its place; and reattached the 
top cover. The Qwiic wire came out between the cover and the case, like this:

![Picture of the Artemis Nano with wires protruding from the shell of the car.](Lab4/Images/FrontView.jpg)

Wrote code to make the robot drive in a straight line (using a linear scaling calibration) and took a video.

### Simulation

Downloaded the Lab 4 Base Code from Box into the folder shared between the host and the VM. In the VM, opened a terminal window; entered the shared folder; extracted the base code; and ran `setup.sh` in the appropriate folder.

Closed and reopened terminal window. Ran `lab4-manager` and followed the instructions to open a simulator window.

Opened another terminal window (`Ctrl+Alt+T`). Entered the directory `/home/artemis/catkin_ws/src/lab4/scripts` and ran `jupyter lab`.

In the resulting Firefox window, opened the Jupyter notebook `lab4.ipynb`. Followed the instructions and saved the lab notebook.

## Results and Notes

### Physical Robot

Running the example code, when the motor driver was plugged in, gave the result

	I2C device found at address 0x5D  !

Not surprisingly, the addresses of the wheel motors were 0 and 1 (since the SCMD drives up to two motors.)

The minimum power at which I could make the wheels spin was not the same on either side. On the left (address 0) it was about 46; on the right (address 1) it was about 50. These numbers seem to change as the battery level changes.

I reasoned that the friction in the wheels is a constant force, not a velocity-dependent one, so the frictional resistance should be a constant offset. This seemed to to work; at low power, I needed +4 power on the right side, and the same should be true at higher power levels. However, the wheels were not exactly the same size, as evidenced by the fact that the robot drove in a curve. By trial and error, I scaled the left side up by 8% to compensate for this, and then the robot drove straighter.

When I assembled the robot, I found that the electrical tape wasn't sticky enough to hold the Artemis Nano onto the robot case; and zip ties would prevent me from replacing the battery. So I used duct tape instead.

Below is a video of a straight line (triggered by a whistle).

<video width="600" controls><source src="Lab4/Videos/DriveStraightWhistle.mp4" type="video/mp4"></video>

Also, note that I could not set to recognize higher-frequency whistles, or else the robot would pick up the sound of its own motors and keep on driving.

### Simulation

```shell
artemis@artemis-VirtualBox:~$ cd Shared
artemis@artemis-VirtualBox:~/Shared$ ls
 ...
 lab4_base_code.zip
...
artemis@artemis-VirtualBox:~/Shared$ unzip lab4_base_code.zip
Archive:  lab4_base_code.zip
   creating: lab4_base_code/
  inflating: lab4_base_code/bash_aliases  
  inflating: lab4_base_code/setup.sh  
  inflating: lab4_base_code/lab4.zip  
artemis@artemis-VirtualBox:~/Shared$ ls
...
 lab4_base_code
 lab4_base_code.zip
...
artemis@artemis-VirtualBox:~/Shared$ cd ./lab4_base_code/
artemis@artemis-VirtualBox:~/Shared/lab4_base_code$ ls
bash_aliases  lab4.zip  setup.sh
artemis@artemis-VirtualBox:~/Shared/lab4_base_code$ ./setup.sh 
 > Log output written to: /home/artemis/Shared/lab4_base_code/output_lab4.log 
 > Lab Work Directory: /home/artemis/catkin_ws/src/lab4/scripts/ 
Validating...
Step 1/3: Extracting Files to: /home/artemis/catkin_ws/src/ 
Step 2/3: Setting up commands
Step 3/3: Compiling Project

Successfully compiled lab.
NOTE: Make sure you close all terminals after this message.
artemis@artemis-VirtualBox:~/Shared/lab4_base_code$ exit
```

My working open-loop square was as follows:

```python
# Your code goes here
for i in range(4):
    robot.set_vel(1,0)
    time.sleep(0.5)
    robot.set_vel(0,1)
    time.sleep(1.625)
robot.set_vel(0,0)
```

See the rest of my code, and the Jupyter notebook, [here](https://github.com/kreismit/ECE4960/tree/master/Lab4).
