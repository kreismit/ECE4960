# In world coordinates
def compute_control(cur_pose, prev_pose):
    """ Given the current and previous odometry poses, this function extracts
    the control information based on the odometry motion model.

    Args:
        cur_pose  ([Pose]): Current Pose
        prev_pose ([Pose]): Previous Pose 

    Returns:
        [delta_rot_1]: Rotation 1  (degrees)
        [delta_trans]: Translation (meters)
        [delta_rot_2]: Rotation 2  (degrees)
    Pseudocode (well, this code probably compiles):
        delta_y = curr_pose[1] - prev_pose[1]
        delta_x = curr_pose[0] - prev_pose[0]
        delta_rot_1 = atan2(delta_y, delta_x)
        delta_trans = sqrt(delta_y^2 + delta_y^2)
        delta_rot_2 = curr_pose[2] - (prev_pose[2] + delta_rot_1)
    """

    return delta_rot_1, delta_trans, delta_rot_2

# In world coordinates
def odom_motion_model(cur_pose, prev_pose, u):
    """ Odometry Motion Model

    Args:
        cur_pose  ([Pose]): Current Pose
        prev_pose ([Pose]): Previous Pose
        u = (rot1, trans, rot2) (float, float, float): A tuple with control data
            in the format (rot1, trans, rot2) with units (degrees, meters, degrees)

    Returns:
        prob [numpy array 18x18x20]: Probability p(x'|x, u)
        
    Pseudocode:
        for x,y in gridPoints:
            r = sqrt(x^2+y^2)
            theta = atan2(y,x)
            pR = gaussian(r, trans, odom_trans_sigma)
            pTh = gaussian(theta, rot1, odom_rod_sigma) for any theta
            pXY = pR*pTh # probability we got R and Theta right
            prob[indices for x & y] = pXY
    """

    return prob

def prediction_step(cur_odom, prev_odom):
    """ Prediction step of the Bayes Filter.
    Update the probabilities in loc.bel_bar based on loc.bel 
    from the previous time step and the odometry motion model.

    Args:
        cur_odom  ([Pose]): Current Pose
        prev_odom ([Pose]): Previous Pose
        
    Returns:
        loc.bel_bar [float array 20x20]: Updated location probability density
        
    Pseudocode:
        loc.bel_bar = odom_motion_model(cur_odom, prev_odom)*loc.bel
    """
    
    return loc.bel_bar

def sensor_model(obs):
    """ This is the equivalent of p(z|x).
    Args:
        obs [ndarray]: A 1D array consisting of the measurements made in rotation loop

    Returns:
        probArray [ndarray]: Returns a 1D array of size 18 (=loc.OBS_PER_CELL) with the likelihood of each individual measurements
    Pseudocode:
        for i in range(18):
        d = distanceToWallMap();
        probArray[i] = gaussian(obs[i], d, sensor_sigma)
    """

    return prob_array

# In configuration space
def update_step(loc.bel_bar, obs):
    """ Update step of the Bayes Filter.
    Update the probabilities in loc.bel based on loc.bel_bar and the sensor model.
    Args:
        loc.bel_bar: belief after prediction step
        obs [ndarray]: A 1D array consisting of the measurements made in rotation loop
    Returns:
        loc.bel [ndarray 18x20x20]: belief after update step
    Pseudocode:
        loc.bel = sensorModel(obs)*loc.bel_bar
        eta = 1/sum(loc.bel)    # normalization constant
        loc.bel = loc.bel*eta
    """
